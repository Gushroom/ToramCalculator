member的行为可能有：切换目标，移动，使用技能，使用道具，使用格挡，使用闪躲等。我不确定这是否是所有可能的行为。

有关技能的声明周期：

1.技能开始：记录操作，判断技能可用性
2.前摇开始：修改特定角色状态，比如锁定可操作性；计算前摇时长；执行前摇动画
3.蓄力开始：修改特定角色状态，比如允许闪躲；计算蓄力时长；执行蓄力动画
4.计算技能效果：执行技能效果，生成事件插入到事件队列，比如30帧后怪物HP-300
5.技能动画结束：修改特定角色状态，比如可操作性

✅ 模拟器架构总览（精简版）
🧩 核心模块
模块	所在线程	说明
🎮 控制器 Controller	主线程	收集用户输入，转发为意图事件
🧠 状态机 FSM	Worker	控制行为流程与状态过渡，决定是否接受控制器输入
⚙️ 引擎 GameEngine	Worker	推进帧循环，处理事件，调用 FSM、更新属性
👤 角色 Player	Worker	持有属性 + FSM，暴露行为接口（如使用技能）
🖼️ 渲染器 Renderer	主线程 + OffscreenCanvas	渲染表现，响应 FSM 发出的动画事件

❗ 1. 引擎是“时间驱动器”不是“决策者”
你的游戏引擎的职责是类似于：

每帧推进游戏状态（tick）

遍历事件队列

调用 player.update()、fsm.send(...) 等接口

它并不关心某个行为是否“正确”，比如你是否可以释放技能、当前状态合不合法，那些是 FSM 的责任。

✅ 2. 状态机是“控制规则”，必须保持可替换、可测试、可插拔
举个例子：

你以后可能想做一个「AI 操控」系统，就要用一套不同的状态机策略。

你可能支持“无敌模式”“PVP模式”，状态转换规则都要变。

如果 FSM 是嵌在引擎里的逻辑，那修改一处规则你就得动核心引擎。

所以保持 FSM 为独立单元，是为了保持整个模拟系统的 可维护性与扩展性。

✅ 推荐结构：Engine ≈ 核心运行时容器
引擎内部组成：

模块	说明
🧠 数据管理器（MemberRegistry / WorldState）	管理所有实体（如 Players/NPCs），负责统一访问、创建、销毁等生命周期操作。也包含对状态机（FSM）的引用。
📮 消息路由器（MessageRouter）	接收外部指令（控制器/AI），分发给相应的 FSM / 实例处理。
⏱ 时间推进器（FrameLoop）	推进帧（如每 16ms），调度事件执行、状态推进等。可按需加速或暂停。
📋 事件队列（EventQueue）	包含将要执行的时间片段（如技能、Buff结算、状态迁移等），每帧处理当前队列中的事件。支持插入、优先级排序、快照记录等。
🗃 日志记录 / 状态快照系统	可选模块，用于记录历史帧状态，用于回滚、分析、复盘等。
🧮 计算工具集（FormulaEngine, BuffEngine）	封装属性结算、技能效果等运算逻辑，避免污染实体代码逻辑。

🎯 控制器的连接方式
控制器（主线程） → 向 Worker 引擎发送 意图消息（如技能使用）

引擎中 MessageRouter 接收并根据 ID/标签分发给具体 Player 的 FSM

FSM 检查合法性并生成行为事件（如“释放技能前摇”），加入事件队列

下一帧，时间推进器调用事件处理逻辑

状态更新后回传快照或渲染事件至主线程
