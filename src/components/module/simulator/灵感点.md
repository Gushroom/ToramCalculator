member的行为可能有：切换目标，移动，使用技能，使用道具，使用格挡，使用闪躲等。我不确定这是否是所有可能的行为。

有关技能的声明周期：

1.技能开始：记录操作，判断技能可用性
2.前摇开始：修改特定角色状态，比如锁定可操作性；计算前摇时长；执行前摇动画
3.蓄力开始：修改特定角色状态，比如允许闪躲；计算蓄力时长；执行蓄力动画
4.计算技能效果：执行技能效果，生成事件插入到事件队列，比如30帧后怪物HP-300
5.技能动画结束：修改特定角色状态，比如可操作性

其实我有个想法，将角色状态机与他们的控制器分开，Player的使用玩家控制器输出角色行为。而其他类型的Member则使用AI控制器，根据member对应的actions逻辑生成行为并输出

Todos记录：

📋 双引擎架构重构 To-Dos
阶段1：创建基础架构 (Foundation)
1.1 创建引擎目录结构
[ ] 创建 src/components/module/simulator/engines/ 目录
[ ] 创建 src/components/module/simulator/engines/shared/ 子目录
[ ] 创建 src/components/module/simulator/engines/interfaces/ 子目录
1.2 定义统一引擎接口
[ ] 创建 engines/interfaces/IGameEngine.ts
定义统一的引擎接口
包含start/stop/getSnapshots等基础方法
定义引擎状态枚举
1.3 创建共享数据结构
[ ] 创建 engines/shared/SharedGameData.ts
定义阵营、队伍、成员的基础数据结构
创建事件类型定义
定义快照接口
1.4 创建事件总线
[ ] 创建 engines/shared/EventBus.ts
实现事件发布/订阅机制
支持事件过滤和优先级
提供事件历史记录
阶段2：实现固定流程引擎 (Fixed Flow Engine)
2.1 重构GameEngine为FixedFlowGameEngine
[ ] 创建 engines/FixedFlowGameEngine.ts
基于现有GameEngine.ts重构
实现IGameEngine接口
移除实时控制相关代码
优化为批量处理模式
2.2 创建AI控制器
[ ] 创建 engines/shared/AIController.ts
实现AI决策逻辑
支持不同类型的AI行为
提供可配置的AI策略
2.3 创建批量处理器
[ ] 创建 engines/shared/BatchProcessor.ts
实现高性能批量计算
支持任务分片和并行处理
提供进度回调机制
阶段3：实现实时引擎 (Realtime Engine)
3.1 重构RealtimeSimulatorManager为RealtimeGameEngine
[ ] 创建 engines/RealtimeGameEngine.ts
基于RealtimeSimulatorManager重构
实现IGameEngine接口
集成PlayerMachine状态机
实现外部控制接口
3.2 创建外部控制器接口
[ ] 创建 engines/shared/ExternalController.ts
定义外部控制接口
实现技能、移动、状态控制
提供控制事件转换机制
3.3 创建成员状态机管理器
[ ] 创建 engines/shared/MemberStateManager.ts
管理不同类型的成员状态机
支持Player/AI状态机切换
提供状态同步机制
阶段4：创建引擎工厂 (Engine Factory)
4.1 实现引擎工厂
[ ] 创建 engines/GameEngineFactory.ts
实现工厂模式创建引擎
支持配置驱动的引擎选择
提供引擎生命周期管理
4.2 创建引擎配置接口
[ ] 创建 engines/interfaces/EngineConfig.ts
定义引擎配置接口
支持性能参数配置
提供默认配置
阶段5：重构现有组件 (Component Refactoring)
5.1 重构SimulatorPool
[ ] 更新 SimulatorPool.ts
适配新的引擎接口
使用GameEngineFactory创建引擎
更新任务处理逻辑
5.2 重构PlayerController
[ ] 更新 PlayerController.tsx
使用FixedFlowGameEngine
更新API调用方式
保持UI功能不变
5.3 重构RealtimePlayerController
[ ] 更新 RealtimePlayerController.tsx
使用RealtimeGameEngine
更新控制接口调用
保持实时控制功能
阶段6：重构状态管理 (State Management)
6.1 重构playerState为共享模块
[ ] 重构 playerState.ts
提取为 engines/shared/PlayerStateManager.ts
移除XState依赖
提供纯计算功能
6.2 创建成员状态计算器
[ ] 创建 engines/shared/MemberStateCalculator.ts
实现成员状态计算逻辑
支持不同类型成员的计算
提供缓存和优化机制
阶段7：清理和优化 (Cleanup & Optimization)
7.1 删除废弃文件
[ ] 删除 Simulation.worker.ts (备份后删除)
[ ] 删除 memberState.ts (功能已整合)
[ ] 更新导入路径
7.2 更新文档
[ ] 更新 架构设计概要.md
[ ] 更新 Worker运行逻辑设计.md
[ ] 创建新的架构文档
7.3 性能优化
[ ] 优化FixedFlowGameEngine的批量处理性能
[ ] 优化RealtimeGameEngine的响应性
[ ] 实现内存池和对象复用
阶段8：测试和验证 (Testing & Validation)
8.1 单元测试
[ ] 为IGameEngine接口创建测试
[ ] 为FixedFlowGameEngine创建测试
[ ] 为RealtimeGameEngine创建测试
8.2 集成测试
[ ] 测试SimulatorPool与新引擎的集成
[ ] 测试UI控制器与新引擎的集成
[ ] 验证双引擎切换功能
8.3 性能测试
[ ] 对比新旧架构的性能
[ ] 测试批量处理的吞吐量
[ ] 测试实时控制的延迟
阶段9：部署和监控 (Deployment & Monitoring)
9.1 部署准备
[ ] 创建部署脚本
[ ] 准备回滚方案
[ ] 更新版本号
9.2 监控和日志
[ ] 添加引擎性能监控
[ ] 实现详细的日志记录
[ ] 创建错误报告机制
🎯 执行优先级
高优先级 (立即执行)：
阶段1：创建基础架构
阶段2：实现固定流程引擎
阶段3：实现实时引擎
中优先级 (并行执行)：
阶段4：创建引擎工厂
阶段5：重构现有组件
低优先级 (最后执行)：
阶段6-9：优化、测试、部署
📝 注意事项
保留test文件夹：所有test/目录下的文件保持不变
渐进式重构：每个阶段完成后进行测试
向后兼容：确保现有功能不受影响
性能监控：持续监控重构对性能的影响