# Worker运行逻辑设计

## 核心架构思路

### Worker管理策略：Worker池模式

**设计选择：Worker池 > 按需创建**

**理由：**
- 用户在装备界面频繁对比，需要快速响应
- Worker初始化开销（50-100ms）在多次计算中累积显著
- 内存占用可控（池大小=CPU核心数，最多8个）

**架构模式：**
```
主线程：WorkerPool管理器 + 任务调度
Worker池：预创建的独立模拟器实例  
通信：Comlink + 自定义消息协议
```

## 双模式运行逻辑

### 固定流程模式（批量计算）
```
目标：装备对比、DPS统计
流程：连续计算 → 最终结果输出
特点：高性能、无暂停、适合并行
```

### 实时输入模式（交互模拟）
```
目标：战斗模拟、策略验证  
流程：计算 + 实时输出 + 暂停等待
暂停点：技能动画结束、方向键松开
特点：交互性、每帧输出、单Worker
```

## 状态机设计理念

### XState管理生命周期
```
职责：Worker级别的状态控制
状态：初始化 → 运行 → 暂停/完成/失败
优势：清晰的状态转换、错误处理、可视化调试
```

### 状态转换逻辑
```
通用流程：
初始化 → 运行 → 完成

实时模式扩展：
运行 → 暂停 → 等待输入 → 运行
```

## 通信协议设计

### 主线程 → Worker
```
任务启动：{ type: 'start_simulation', taskId, config }
用户输入：{ type: 'user_input', data }
取消任务：{ type: 'cancel' }
```

### Worker → 主线程
```
固定模式：{ type: 'simulation_complete', result }
实时模式：{ type: 'frame_data', frameData }
暂停请求：{ type: 'paused', waitingFor }
错误报告：{ type: 'error', message }
```

## 资源管理策略

### Worker生命周期
```
创建：应用启动时预创建池
分配：按需分配给计算任务
回收：任务完成后回收到池
销毁：任务出错或取消时销毁Worker
```

### 任务隔离
```
原则：每个任务独立的Worker实例
优势：无状态污染、计算隔离、错误隔离
实现：任务ID跟踪、状态清理
```

## 性能考量

### 并行计算优势
```
装备对比：8个装备 = 8个Worker并行
加速比：理论8倍（受CPU核心数限制）
响应时间：Worker池消除初始化延迟
```

### 内存管理
```
池大小：min(CPU核心数, 8)
内存占用：每Worker约50MB，总计400MB内存预算
清理策略：任务完成后状态重置
```

## 错误处理策略

### 错误分类
```
初始化错误：配置问题、资源不足
计算错误：引擎异常、数据错误
通信错误：消息格式、网络问题
```

### 处理方式
```
日志记录：发送到控制台
任务终止：停止当前计算
Worker销毁：避免状态污染
用户通知：友好的错误提示
```

## 扩展性设计

### 模块化架构
```
WorkerPool：可配置池大小和策略
TaskManager：支持不同类型的计算任务
MessageProtocol：可扩展的通信格式
```

### 未来扩展点
```
新计算模式：技能对比、装备优化等
性能优化：WebAssembly集成、GPU计算
调试工具：性能监控、状态可视化
``` 